#! /usr/bin/env python

from subprocess import check_output, call
from pprint import pprint
import logging
import sys
import re


log = logging.getLogger('git-wtf')

def red(s):
    return "\033[31m%s\033[0m" % s

def green(s):
    return "\033[32m%s\033[0m" % s

def yellow(s):
    return "\033[33m%s\033[0m" % s

def cyan(s):
    return "\033[36m%s\033[0m" % s

def grey(s):
    return "\033[1;30m%s\033[0m" % s

def purple(s):
    return "\033[35m%s\033[0m" % s

class GitWtf(object):

    def __init__(self):
        self.explain = False

    def run(self, cmd):
        if self.explain:
            return sys.stdout.write("-- %s\n" % cmd)
        if call(cmd, shell=True):
            print "Command '%s' returned non-zero exit status" % cmd
            sys.exit(1)

    def commits_between(self, branch, _from, to):
        if _from == to:
            return []
        cmd = "git log %s --pretty='- [%%h] %%s' %s..%s" % (branch, _from, to)
        commits = check_output(cmd, shell=True).rstrip()
        return commits.split('\n')

    def remotes(self):
        result = {}
        remotes = check_output("git config --get-regexp ^remote\.\*\.url", shell=True).rstrip()
        for line in remotes.split('\n'):
            match = re.match('^remote\.(.+?)\.url (.+)$', line)
            if match:
                result[match.group(1)] = match.group(2)
        return result

    def tracked(self):
        result = {}
        tracked = check_output("git config --get-regexp ^branch\.", shell=True).rstrip()

        for line in tracked.split('\n'):
            # If this line has a remote branch name
            match = re.match('branch\.(.*?)\.remote (.+)', line)
            if match:
                result.setdefault(match.group(1), {})['remote'] = match.group(2)
                continue
            # If this line has a merge path
            match = re.match('branch\.(.*?)\.merge ((refs\/)?heads\/)?(.+)', line)
            if match:
                result.setdefault(match.group(1), {})['merge'] = line.split(' ')[1]
                continue
        return result

    def branches(self):
        result = {}
        branches = check_output("git show-ref", shell=True).rstrip()

        for line in branches.split('\n'):
            sha, ref = line.split(" refs/")
            # Matched a local branch
            match = re.match('^heads\/(.+)$', ref)
            if match:
                head = result.setdefault('local', {})
                # Record the last commit in the branch, and the ref location
                head[match.group(1)] = {'ref': ref, 'sha': sha}
            # Matched a remote branch
            match = re.match('^remotes\/(.+?)\/(.+)$', ref)
            if match:
                remote = result.setdefault(match.group(1), {})
                # Record the last commit in the branch, and the ref location
                remote[match.group(2)] = {'ref': ref, 'sha': sha}
        return result

    def find_remotes(self, branch, status, all):
        result = []
        for remote, branches in all.items():
            if remote == 'local':
                continue
            if branch in branches:
                # If this is our master, and we found our masters origin
                if branch == 'master' and status['tracked']['remote'] == remote:
                    return [branches[branch]]
                # append the branch info to the list of remotes
                result.append(branches[branch])
        return result

    def find_tracked(self, branch, status, tracked, all):
        result = []
        info = tracked[branch]
        # Only include tracked branch if the remote name differs
        # TODO: Remove this if statement, might be better then find_remotes()
        if not info['merge'].endswith(branch):
            # Get the remote name from the ref
            match = re.match('((refs\/)?heads\/)?(.+)', info['merge'])
            remote_name = match.group(3)
            # Add this branch to our tracked info
            status['tracked'] = info
            # Add this branch to our remotes
            status['remotes'].append(all[info['remote']][remote_name])
        return status

    def status(self):
        local = {}

        # List tracked branches
        tracked = self.tracked()
        # List all branches
        all = self.branches()

        # Build a tree of information about our local branches
        for remote, branches in all.items():
            # Only interested in local branches
            if remote != 'local':
                continue

            # for all the local branches
            for branch, status in branches.items():
                # If the branch is tracking a remote branch
                if branch in tracked.keys():
                    status['tracked'] = tracked[branch]
                # Find remote branches with the same name,
                # assume they are remotes of our local branch
                # (This might result in false positives)
                status['remotes'] = self.find_remotes(branch, status, all)
                # Find tracked branches, even if the branch 
                # name doesn't match the remote branch name
                status = self.find_tracked(branch, status, tracked, all)
                local[branch] = status
        # Return a dict of local branches with all available stat info
        return local

    def wtf(self):
        status = self.status()
        for key, value in status.items():
            # Print the branch name and remote that it's tracking
            branch = "%s" % key
            if 'tracked' in value:
                branch = "%s [%s]" % (yellow(key), value['tracked']['remote'])
            print branch
            for remote in value['remotes']:
                print "     %s" % remote['ref'],
                #print "         Sha: %s" % remote['sha']
                #print "       local: %s" % value['sha']
                behind = self.commits_between(key, remote['sha'], value['sha'])
                if behind:
                    print green("is %d commit behind" % len(behind))
                    continue
                ahead = self.commits_between(key, value['sha'], remote['sha'])
                if ahead:
                    print red("is %d commit ahead" % len(ahead))
                    continue
                print ""


def main():
    wtf = GitWtf()
    wtf.wtf()
    return 0


if __name__ == '__main__':
    sys.exit(main())

